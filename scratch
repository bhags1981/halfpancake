팬케이크 그래프 설계
Config : N 값

목적 : N의 모든 출발 정점에 대해서 서로소인 경로를 출력

케이스 확인
케이스별 알고리즘 실시

알고리즘 세분화.
1.정점의 외부 서브 그래프를 취득 하는 알고리즘
2.두개의 서브 그래프를 연결하는 알고리즘
3.서로 다른 퍼뮤테이션을 취득하는 메소드.
4.스텝을 확인하고 진행시키는 클래스


- Vertex Manager
- Disjoint Observer
- Unique permutation manager
- Path manager
- Create Path
-- a ~> b
-- sub graph
- Result Print
- Validator


1.n 확인
2.case 확인
3.케이스별 로직 실행

- 전체 공통 부분
-- 정점 정보, 프리픽스 리버스 정보


케이스별 로직
- 출발 정점의 외부 점을 취득하는 로직
-- 1.단순히 취득 하는 경우 2.외부점을 목적 정점의 외부정점과 반드시 하나는 만나도록 취득하는경우

- 목적 정점의 외부 점을 취득하는 로직
-- 1.단순히 취득 하는 경우 2.외부점을 출발 정점의 외부정점과 반드시 하나는 만나도록 취득하는경우

- 서브그래프를 병렬로 이동시 퍼뮤테이션을 취득하는경우


n에 대해서 전 패턴을 실험. 어떻게??

n의 모든 퍼뮤테이션을 순서대로 취득하기..
123456





1. n 을 지정
2. 모든 퍼뮤테이션을 파일에 저장.
3. 저장된 파일에서 위에서 순서대로 하나씩 취득
4. 취득된 퍼뮤테이션으로 데이터 생성 장소를 확보
5. 취득된 퍼뮤테이션을 바탕으로 알고리즘 실행


퍼뮤테이션별 알고리즘
1. 케이스 확인
2. 케이스별 알고리즘 조합
3. 알고리즘을 스텝별로 실행.

알고리즘 실행중 저장 데이터
1.취득된 정점 정보
2.사용된 유니크 퍼뮤테이션 정보





error - pattern
source [679854321] dest [123456789]
하나의 패스안에 중복 패스가 있음
findDisjointPathsSpecificSourceStart with Source ID 679854321
[1483379950136] [HPDisjointPathService] initialized N2N with source = 679854321 and 123456789
[1483379950164] [HPDisjointPathService]  Start find disjoint paths.
[1483379950164] Start construct disjoint paths between {123456789} and {679854321} by Case 1-3 service.
[1483379950165] [Step 1] Is exist position L ? {-1} (-1 is false)

Node id 987654312 is already used.
[1483379950136] [HPDisjointPathService] initialized N2N with source = 679854321 and 123456789
[1483379950164] [HPDisjointPathService]  Start find disjoint paths.
[1483379950164] Start construct disjoint paths between {123456789} and {679854321} by Case 1-3 service.
[1483379950165] [Step 1] Is exist position L ? {-1} (-1 is false)
[1483379950174] [Step 2] Select path p2 result =  [123456789, 213456789, 987654312, 567894312, 987654312, 897654312, 679854312, 213458976, 123458976, 679854321]
[1483379950175] [Step 3] Select [3]th path result = [123456789, 321456789, 987654123, 678954123, 321459876, 123459876, 678954321]
[1483379950175] [Step 3] Select [4]th path result = [123456789, 432156789, 987651234, 789651234, 432156987, 123456987, 789654321]
[1483379950175] [Step 3] Select [5]th path result = [123456789, 543216789, 987612345, 897612345, 543216798, 123456798, 897654321]
[1483379950175] [Step 4] Select path result = [123456789, 987654321]
[1483379950175] [Step 5] Path[1] : [123456789, 213456789, 987654312, 567894312, 987654312, 897654312, 679854312, 213458976, 123458976, 679854321]
[1483379950175] [Step 5] Path[2] : [123456789, 321456789, 987654123, 678954123, 321459876, 123459876, 678954321, ~PNS~, 679854321]
[1483379950175] [Step 5] Path[3] : [123456789, 432156789, 987651234, 789651234, 432156987, 123456987, 789654321, ~PNS~, 679854321]
[1483379950175] [Step 5] Path[4] : [123456789, 543216789, 987612345, 897612345, 543216798, 123456798, 897654321, ~PNS~, 679854321]
[1483379950175] [Step 5] Path[5] : [123456789, 987654321, ~PNS~, 679854321]
[1483379950175] [Step 6] Finished construct disjoint paths from {123456789} to {679854321} - Terminate.

[123456789, 213456789, 987654312, 567894312, 987654312, 897654312, 679854312, 213458976, 123458976, 679854321]
[123456789, 321456789, 987654123, 678954123, 321459876, 123459876, 678954321, ~PNS~, 679854321]
[123456789, 432156789, 987651234, 789651234, 432156987, 123456987, 789654321, ~PNS~, 679854321]
[123456789, 543216789, 987612345, 897612345, 543216798, 123456798, 897654321, ~PNS~, 679854321]
[123456789, 987654321, ~PNS~, 679854321]

Process finished with exit code 0



2._n 는 왜 필요한가?
    /**
     * Select path r2: s→s(2)→s(2,n)→s(2,n,˜n),a2→ a2(n)→ a2(n,2)→ a2(n,2,n) = d where a2 = (1,2,...,n−2,n,n−1).
     */
    private fun step2(sourceNode: HalfPancakeNode,destinationNode: HalfPancakeNode){
        var n = sourceNode.getLength()
        var _n = _sourceNode.getHalfPosition()

        var tmpPathFromSourceNode = UniquePath(sourceNode).append(2).append(n)//.append(_n)

